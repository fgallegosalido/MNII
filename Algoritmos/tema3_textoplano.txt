Programas Tema 3. Grupo 3
Método de Euler:

Euler(f, x0, y0, x1, n):=block(
    vx : makelist(0,n),
    vy : makelist(0,n),
    h : (x1 - x0) / float(n),
    x:x0,
    y:y0,
    vx[1]:x0,
    vy[1]:y0,
    for i from 1 thru n do(
        k: (f(x, y)),
        vx[i]: x0 + i*h,
        vy[i]: y + h*k,
        y : vy[i],
        x : vx[i]
    ),
        [vx,vy]
)$

f_euler(x,y):=x*sqrt(y)$
f_euler2(x,y):=x$
f_euler3(x,y):=-y+x+1$
Euler(f_euler,0,1,10,10);
Euler(f_euler2,0,1,5,10);
Euler(f_euler3,0,1,1,10);




Método de Taylor de orden r. En este caso considera además como dato
de entrada el orden r.

eval_derivada(f, x0, y0, k):=block(
    valor:subst([u=x0,v=y0],diff(f(u,v),v,k-1)),
    return(valor)
)$

funcion_taylor(f, x0, y0, h, r):=block(
    g:sum(1/(k!)*h^(k-1)*eval_derivada(f,x0,y0,k), k, 1, r),
    return(g)
)$

taylor_r(f, x0, y0, x1, r, n):=block(
    vx : makelist(0,n),
    vy : makelist(0,n),
    h : (x1 - x0) / float(n),
    x:x0,
    y:y0,
    vx[1]:x0,
    vy[1]:y0,
    for i from 1 thru n do(
        k:funcion_taylor(f,x,y,h,r),
        vx[i]: x0 + i*h,
        vy[i]: y + h*k,
        y : vy[i],
        x : vx[i]
    ),
        [vx,vy]
)$

f_taylor(x,y):=x$
f_taylor2(x,y):=x*sqrt(y)$
taylor_r(f_taylor,0,1,5,7,10);
taylor_r(f_taylor2,0,1,10,7,10);




Método de Runge-Kutta de orden 4.

rk4(f, x0, y0, x1, n):=block(
    vx : makelist(0,n),
    vy : makelist(0,n),
    h : (x1 - x0) / float(n),
    x:x0,
    y:y0,
    vx[1]:x0,
    vy[1]:y0,
    for i from 1 thru n do(
        k1: (h * f(x, y)),
        k2: (h * f(x + 0.5 * h, y + 0.5 * k1)),
        k3: (h * f(x + 0.5 * h, y + 0.5 * k2)),
        k4: (h * f(x + h, y + k3)),
        vx[i]: x0 + i*h,
        vy[i]: y + (k1 + 2*k2 + 2*k3 + k4) / 6,
        y : vy[i],
        x : vx[i]
    ),
        [vx,vy]
)$

f_rk4(x,y):=x*sqrt(y)$
rk4(f_rk4,0,1,10,10);
f_rk4_2(x,y):=x$
rk4(f_rk4_2,0,1,5,10);





Método del trapecio, usando el método de Newton para aproximar
la solución de la ecuación no lineal.

trapecio(f, x0, y0, x1, n):=block(
    vx : makelist(0,n),
    vy : makelist(0,n),
    h : (x1 - x0) / float(n),
    x:x0,
    y:y0,
    vx[1]:x0,
    vy[1]:y0,
    for i from 1 thru n do( 
        vx[i]: x0 + i*h,
        vy[i]: y + h/2*(f(x,y)+f(vx[i],vy[i])),
        y : vy[i],
        x : vx[i]
    ),
        [vx,vy]
)$

f_trapecio(x,y):=log((x+1)^2)$
f_trapecio2(x,y):=x$
trapecio(f_trapecio,0,1,10,10);
trapecio(f_trapecio2,0,1,5,10);





Método de Adams-Bashforth de k pasos. En este caso considera
además como datos de entrada, el número k y los valores
u1,...,uk−1, obtenidos por otro método de un paso.
